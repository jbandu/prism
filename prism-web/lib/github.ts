// lib/github.ts

import { Octokit } from '@octokit/rest';

const octokit = new Octokit({
  auth: process.env.GITHUB_TOKEN,
});

const REPO_OWNER = process.env.GITHUB_REPO_OWNER || 'jbandu';
const REPO_NAME = process.env.GITHUB_REPO_NAME || 'prism';

export interface GitHubIssue {
  number: number;
  url: string;
  htmlUrl: string;
}

export interface GitHubPR {
  number: number;
  url: string;
  htmlUrl: string;
}

// Create GitHub issue for feature request
export async function createFeatureIssue(data: {
  featureId: string;
  title: string;
  requestedBy: string;
  company: string;
  initialRequest: string;
  finalRequirements: string;
  estimatedComplexity: string;
  tags: string[];
}): Promise<GitHubIssue> {
  try {
    const issueBody = `## ðŸš€ Feature Request (Autonomous)

**Feature ID:** ${data.featureId}
**Requested by:** ${data.requestedBy} (${data.company})
**Complexity:** ${data.estimatedComplexity}
**Tags:** ${data.tags.join(', ')}

### Initial Request
${data.initialRequest}

### Refined Requirements
${data.finalRequirements}

---

### Implementation Checklist
- [ ] Code generated by Claude Code
- [ ] Tests passing
- [ ] Preview deployed
- [ ] Reviewed (if needed)
- [ ] Merged to main
- [ ] Deployed to production

---
*This issue was created automatically by PRISM's autonomous feature system.*
*Feature will be implemented by AI and deployed automatically.*
`;

    const issue = await octokit.issues.create({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      title: `feat: ${data.title}`,
      body: issueBody,
      labels: ['autonomous', 'feature', data.estimatedComplexity, ...data.tags],
    });

    return {
      number: issue.data.number,
      url: issue.data.url,
      htmlUrl: issue.data.html_url,
    };
  } catch (error) {
    console.error('Error creating GitHub issue:', error);
    throw new Error(`Failed to create GitHub issue: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Create pull request
export async function createPullRequest(data: {
  branch: string;
  title: string;
  body: string;
  issueNumber?: number;
}): Promise<GitHubPR> {
  try {
    const prBody = data.issueNumber 
      ? `${data.body}\n\nCloses #${data.issueNumber}`
      : data.body;

    const pr = await octokit.pulls.create({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      title: data.title,
      head: data.branch,
      base: 'main',
      body: prBody,
    });

    return {
      number: pr.data.number,
      url: pr.data.url,
      htmlUrl: pr.data.html_url,
    };
  } catch (error) {
    console.error('Error creating pull request:', error);
    throw new Error(`Failed to create pull request: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Check if PR checks passed
export async function checkPRStatus(prNumber: number): Promise<{
  state: 'success' | 'failure' | 'pending';
  checksRun: number;
  checksPassed: number;
}> {
  try {
    const pr = await octokit.pulls.get({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      pull_number: prNumber,
    });

    const checks = await octokit.checks.listForRef({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      ref: pr.data.head.sha,
    });

    const totalChecks = checks.data.total_count;
    const passedChecks = checks.data.check_runs.filter(
      check => check.conclusion === 'success'
    ).length;

    let state: 'success' | 'failure' | 'pending';
    if (passedChecks === totalChecks && totalChecks > 0) {
      state = 'success';
    } else if (checks.data.check_runs.some(check => check.conclusion === 'failure')) {
      state = 'failure';
    } else {
      state = 'pending';
    }

    return {
      state,
      checksRun: totalChecks,
      checksPassed: passedChecks,
    };
  } catch (error) {
    console.error('Error checking PR status:', error);
    throw new Error(`Failed to check PR status: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Merge pull request
export async function mergePullRequest(prNumber: number): Promise<void> {
  try {
    await octokit.pulls.merge({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      pull_number: prNumber,
      merge_method: 'squash',
      commit_title: `Autonomous feature deployment (#${prNumber})`,
    });
  } catch (error) {
    console.error('Error merging pull request:', error);
    throw new Error(`Failed to merge pull request: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Add comment to issue
export async function addIssueComment(issueNumber: number, comment: string): Promise<void> {
  try {
    await octokit.issues.createComment({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      issue_number: issueNumber,
      body: comment,
    });
  } catch (error) {
    console.error('Error adding issue comment:', error);
    // Don't throw - this is not critical
  }
}

// Close issue
export async function closeIssue(issueNumber: number): Promise<void> {
  try {
    await octokit.issues.update({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      issue_number: issueNumber,
      state: 'closed',
    });
  } catch (error) {
    console.error('Error closing issue:', error);
    // Don't throw - this is not critical
  }
}
